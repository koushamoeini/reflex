# گزارش جامع پیاده‌سازی پروتکل Reflex

این سند گزارش تلاش‌های تیم ما برای پیاده‌سازی پروتکل ریفلکس در هسته Xray است. ما سعی کردیم تمام استپ‌های خواسته‌شده را با دقت و با رعایت استانداردهای کدنویسی Go پیاده کنیم.

## ساختار تیم و مشارکت‌ها
پروژه به صورت یک همکاری تیمی انجام شد و وظایف به شکل زیر تقسیم گردید:

*   **کوشا معینی (401100228):** مسئولیت پیاده‌سازی زیرساخت پایه (Step 1) شامل تعریف Protobufها و ساختار Accountها. همچنین پیاده‌سازی منطق هندشیک و تبادل کلید X25519 (Step 2).
*   **آرمان آریان‌پور (401170072):** مسئولیت پیاده‌سازی سیستم فریم‌بندی داده‌ها و رمزنگاری AEAD با الگوریتم ChaCha20-Poly1305 (Step 3). همچنین نوشتن سناریوهای تست و مدیریت Replay Attack (Step 4).
*   **پارسا غلامی (401100477):** مسئولیت پیاده‌سازی بخش پیشرفته Traffic Morphing (Step 5)، مدیریت پکت‌های Padding و Timing و در نهایت یکپارچگی با سیستم CI/CD جاج.

---

## جزئیات فنی و مراحل توسعه

### مرحله : اسکلت‌بندی و کانفیگ
در ابتدا پوشه `reflex` را در مسیر `proxy/` ایجاد کردیم. چالش این مرحله فهمیدن نحوه رجیستر شدن پروکسی‌ها در Xray بود. با مطالعه سورس کد پروکسی‌های دیگر مثل VLESS، متوجه شدیم که باید توابع `InboundHandler` و `OutboundHandler` را پیاده کنیم و پروکسی را در فایل‌های توزیع Xray ثبت نماییم.

### مرحله : امنیت در اولین پکت (Handshake)
برای ما مهم بود که هندشیک به هیچ وجه توسط DPI قابل شناسایی نباشد. به همین خاطر از Magic Byteهای ثابت در ابتدای کانکشن خودداری کردیم و به جای آن از یک مکانیزم "Implicit Handshake" استفاده کردیم که فقط کلاینت و سرور با داشتن کلیدهای صحیح قادر به درک آن هستند. از الگوریتم X25519 برای تبادل کلید (ECDH) به دلیل سرعت و امنیت بالا استفاده شد.

### مرحله : محرمانگی و تمامیت داده‌ها
داده‌ها در فریم‌های متغیر بسته‌بندی می‌شوند. هر فریم دارای یک Header است که شامل طول فریم و کد احراز هویت (MAC) می‌باشد. استفاده از ChaCha20-Poly1305 به ما این اطمینان را داد که علاوه بر رمزنگاری، اگر محتوای پکت در مسیر تغییر کند، سرور بلافاصله متوجه شده و کانکشن را قطع می‌کند.

### مرحله : مکانیزم Fallback و مخفی‌کاری
این بخش یکی از چالش‌برانگیزترین قسمت‌ها بود. ما از `bufio.NewReader` در سمت سرور استفاده کردیم تا بتوانیم چند بایت اول را بدون "مصرف شدن" نگاه کنیم (Peek). اگر درخواست ورودی با الگوی ریفلکس مطابقت نداشت، به جای قطع کردن ارتباط، آن را به پورت fallback (معمولاً یک وب‌سرور واقعی) انتقال می‌دهیم. این کار باعث می‌شود اسکنرهای فیلترینگ فکر کنند با یک سرور معمولی طرف هستند.

### مرحله : شبیه‌سازی ترافیک (Traffic Morphing)
در مرحله آخر، برای جلوگیری از تحلیل آماری (Traffic Analysis)، قابلیتی اضافه کردیم که به بسته‌ها Padding تصادفی اضافه می‌کند. همچنین با استفاده از فریم‌های مخصوص `TIMING_CTRL` سعی کردیم فواصل ارسال بسته‌ها را طوری تغییر دهیم که شبیه به رفتار یک کاربر عادی در حال وب‌گردی باشد تا از روی الگوهای زمانی هم قابل شناسایی نباشیم.

## تست و آزمایش
ما مجموعه‌ای از تست‌های Unit و Integration را در پوشه `tests/` قرار دادیم. این تست‌ها شامل موارد زیر هستند:
- تست صحت تبادل کلید X25519.
- تست مقاومت در برابر پکت‌های تکراری (Anti-Replay).
- تست سرعت انتقال داده در شرایط مختلف شبکه.
- تست Fallback با ارسال پکت‌های غیر پروتکلی.

با اجرای دستور `go test ./...` می‌توانید صحت تمام بخش‌ها را تایید کنید. ما به پوشش کد (Coverage) بالای  درصد دست پیدا کردیم که نشان‌دهنده دقت در تست تمام مسیرهای کد است.
